{
  "id": "msg-20260212-711537",
  "thread_id": "thread-20260212-711535",
  "role": "user",
  "content": "FOCUS FLOW OS\nProduct Requirements Document\nVersion 1.2 — Full Architecture Integration\nFebruary 2, 2026\nVERSION HISTORY\nVersion\nDate\nChanges\nv1.0\nFeb 2, 2026\nInitial PRD — core architecture, vault, dashboard, 5-phase plan\nv1.1\nFeb 2, 2026\nSecurity hardening — Nate’s analysis, ClawHub ban, security checklist\nv1.2\nFeb 2, 2026\nFull integration — Spec-kit, Auto-Claude, Stitch, Coolify, Beads, mem0, AI Council, Flowise\n\n\nTable of Contents\n\n\n\n1. Executive Summary\nFocus Flow OS is a self-hosted personal operating system that transforms raw intent into organized action through an AI-powered pipeline. It runs entirely on a Hetzner VPS behind Tailscale, with Telegram as the primary input channel and an Obsidian vault as the canonical knowledge base.\nVersion 1.2 integrates the complete idea-to-deployment pipeline: capture ideas via Telegram or Dashboard, validate them through an AI Council (OpenClaw sub-agents, upgradeable to Flowise), generate specifications with GitHub Spec-kit, design UIs with Google Stitch (via Gemini CLI or manual), build autonomously with Auto-Claude, review through the Dashboard, and deploy via Coolify—all on a single VPS.\n1.1 What Changed in v1.2\nAdded 6 new tools to the architecture: Spec-kit, Auto-Claude, Google Stitch, Coolify, Beads, mem0\nDefined AI Council validation using OpenClaw sub-agents (with Flowise as Phase 3 upgrade)\nMapped complete 8-step workflow from idea capture to production deployment\nEstablished dual memory architecture: Beads (per-project) + mem0 (personal OS)\nAuto-Claude runs on Hetzner VPS via Claude Code CLI, eliminating local compute dependency\nCoolify manages Docker deployments on the same Hetzner VPS\nCode repositories live at /srv/projects/{project}/ with GitHub remotes for backup\nDashboard built with Auto-Claude using Focus Flow design reference (React/Tailwind)\n\n2. System Architecture\nAll services run on a single Hetzner VPS, accessible only via Tailscale. No ports are exposed to the public internet. The architecture is organized into four layers: Input, Intelligence, Storage, and Output.\n2.1 Architecture Layers\nLayer\nComponents\nPurpose\nInput Layer\nTelegram Bot, Dashboard UI, Voice (whisper.cpp + Piper)\nCapture raw intent from user\nIntelligence Layer\nOpenClaw, AI Council, Spec-kit, Auto-Claude, Gemini CLI/Stitch\nProcess, validate, spec, design, and build\nMemory Layer\nBeads (per-project), mem0 (personal), Obsidian Vault\nPersistent context across agents and sessions\nOutput Layer\nCoolify, Dashboard, Telegram responses, Vault notes\nDeploy apps, present information, store knowledge\n\n2.2 Service Map (Single VPS)\nService\nBinds To\nPort\nAccess\nDocker?\nOpenClaw Gateway\n127.0.0.1\n18789\nTailscale Serve\nHost (or Docker)\nOpenClaw Control UI\n127.0.0.1\n3000\nTailscale Serve\nSame as Gateway\nFocus Flow Dashboard\n127.0.0.1\n5173\nTailscale Serve\nDocker (Coolify)\nCoolify\n127.0.0.1\n8000\nTailscale Serve\nDocker\nmem0 Service\n127.0.0.1\n8050\nInternal only\nDocker\nQdrant (mem0 vector DB)\n127.0.0.1\n6333\nInternal only\nDocker\nAuto-Claude\nN/A (CLI)\nN/A\nSSH/Tailscale\nHost\nSyncthing\n127.0.0.1\n8384\nTailscale Serve\nHost\n\n2.3 Network Topology\nZero public exposure. Every service binds to 127.0.0.1 (localhost). Tailscale Serve provides HTTPS routing and identity headers for authenticated services. The Telegram bot connects outbound to Telegram’s API—no inbound ports needed. SSH access is Tailscale-only.\nUFW/iptables: DENY all inbound except Tailscale interface\nTailscale Serve: Routes tailnet HTTPS to localhost services\nTailscale identity headers: Primary authentication for Dashboard and Control UI\nPincer audit: Mandatory pre-deploy check that gateway binds to 127.0.0.1, not 0.0.0.0\n\n3. Complete Workflow Pipeline\nThe core value proposition: from raw thought to deployed application, triggered by a Telegram message or Dashboard action. Each step maps to a specific tool.\n3.1 The 8-Step Pipeline\nStep\nAction\nTool\nInput\nOutput\n1. Capture\nUser sends raw intent\nTelegram / Dashboard\nVoice, text, link\nvault/00_inbox/ entry\n2. Classify\nAI categorizes intent\nOpenClaw\nInbox entry\nTask / Idea / Note / Event\n3. Validate\nAI Council evaluates idea\nOpenClaw sub-agents\nIdea from vault/03_ideas/\nApproved / Rejected / Needs Info\n4. Spec\nGenerate detailed specification\nGitHub Spec-kit\nValidated idea\nvault/02_projects/{p}/SPEC.md\n5. Design\nGenerate UI mockups + code\nGemini CLI → Stitch\nSpec + design reference\nvault/02_projects/{p}/designs/\n6. Build\nAutonomous development\nAuto-Claude\nSpec + designs + Beads context\nGit repo at /srv/projects/{p}/\n7. Review\nUser reviews in Dashboard\nDashboard\nBuild artifacts + preview\nApproved / Revision requested\n8. Deploy\nShip to production\nCoolify\nGit repo\nLive app with SSL\n\n3.2 Step 1 — Capture (Telegram + Dashboard)\nUser sends a message to Telegram or types in the Dashboard’s Quick Capture screen. OpenClaw receives it, extracts intent, and writes a structured note to vault/00_inbox/.\nVault entry format: YAML frontmatter (type, source, timestamp, confidence) + raw text + AI-extracted metadata (entities, dates, action verbs).\n3.3 Step 2 — Classify\nOpenClaw classifies the inbox entry into one of four types: Task, Idea, Note, or Event. Classification uses action verb detection, deadline indicators, and content analysis. Items route to the appropriate vault folder:\nTasks → vault/01_daily/ or vault/02_projects/{project}/tasks/\nIdeas → vault/03_ideas/\nNotes → vault/04_notes/\nEvents → vault/05_events/\n3.4 Step 3 — AI Council Validation\nIdeas that could become projects pass through the AI Council—a set of OpenClaw sub-agents that evaluate from different perspectives.\n3.4.1 Council Architecture (Phase 1: OpenClaw Sub-Agents)\nThree sub-agents evaluate each idea independently, then a synthesizer produces a recommendation:\nAgent\nPerspective\nEvaluates\nFeasibility Agent\nTechnical viability\nCan this be built? What’s the complexity? Dependencies?\nAlignment Agent\nPersonal goals\nDoes this align with current priorities and available time?\nImpact Agent\nValue assessment\nWhat’s the ROI? Will this actually get used?\nSynthesizer\nFinal recommendation\nAggregates scores → Approve / Reject / Needs More Info\n\nOutput: Council verdict written to vault/03_ideas/{idea}/COUNCIL_VERDICT.md with per-agent reasoning, scores, and final recommendation. User receives Telegram notification with summary and can approve/override via Dashboard.\n3.4.2 Council Upgrade Path (Phase 3: Flowise)\nWhen workflows become more complex (multi-step validation, external data fetching, conditional branching), migrate the Council to Flowise—a self-hosted visual workflow builder. Flowise provides drag-and-drop orchestration, persistent state, and can call any LLM or API endpoint. This keeps the Council extensible without rewriting OpenClaw configurations.\n3.5 Step 4 — Specification (GitHub Spec-kit)\nOnce an idea is approved, Spec-kit transforms it into a comprehensive, executable specification.\nSpec-kit is GitHub’s Spec-Driven Development toolkit. It uses /speckit.constitution to define project principles, /speckit.specify to generate detailed feature specifications, /speckit.plan for technical implementation plans, and /speckit.tasks to break plans into actionable tasks. Specs become executable artifacts—they don’t just guide code generation, they drive it.\nConstitution: vault/02_projects/{project}/.specify/memory/constitution.md\nSpecs: vault/02_projects/{project}/.specify/specs/\nPlans: vault/02_projects/{project}/.specify/plans/\nTasks: vault/02_projects/{project}/.specify/tasks/\n3.6 Step 5 — Design (Google Stitch via Gemini CLI)\nUI design is generated using Google Stitch, accessed either through the Gemini CLI (automated path) or manually through the Stitch web interface (fallback).\nPrimary path (Gemini CLI): Feed the specification and design reference into Gemini CLI, which can invoke Stitch to generate HTML/CSS or React component code. Output is saved to vault/02_projects/{project}/designs/.\nFallback path (Manual): Paste spec into stitch.withgoogle.com, download generated code, place in project designs/ folder.\nDesign reference: The 10 Focus Flow mockups (Quick Capture, Voice Cockpit, Project Workspace, Inbox Processing, Calendar, Dashboard, Ideas Explorer, Wellbeing Tracker, Projects Management, Item Processing Panel) serve as the canonical design system for Stitch prompts.\n3.7 Step 6 — Build (Claude code agent teams on Hetzner)\nAuto-Claude runs on the Hetzner VPS via Claude Code CLI. It takes the specification, designs, and Beads project context to autonomously build the application.\n3.7.1 Claude code agent team Pipeline\nPhase\nAgent\nWhat It Does\n1. Spec Review\nSpec Agent\nReads .specify/ folder, validates completeness\n2. Planning\nPlanner Agent\nBreaks spec into implementation chunks, decides architecture\n3. Coding\nCoder Agent\nWrites code, commits to git worktree\n4. QA Review\nQA Reviewer\nReviews code against spec, runs tests, flags issues\n5. QA Fix\nQA Fixer\nFixes flagged issues, re-runs validation\n6. User Review\nDashboard notification\nUser approves or requests revisions\n\nSecurity: Claude-code uses built-in security profiles and command allowlisting. Git worktree isolation ensures each feature builds in an isolated branch. The Docker sandbox recommendation from Nate’s analysis applies—Claude runs inside a container with mounted project directory only.\n3.7.2 Setup: Claude Code on Hetzner\nClaude Code CLI authenticated on the server. Setup flow:\nSSH into VPS via Tailscale\nInstall Claude Code CLI (npm install -g @anthropic-ai/claude-code)\nAuthenticate via device code flow (one-time browser auth)\nClone Auto-Claude repo, configure project paths\nAuto-Claude invokes Claude Code for each build phase\n3.8 Step 7 — Review (Dashboard)\nThe Dashboard’s Project Workspace screen shows build progress, diffs, test results, and a preview link. User can approve, request revisions (sent back to Auto-Claude), or reject.\n3.9 Step 8 — Deploy (Coolify)\nCoolify runs on the same Hetzner VPS, managing Docker containers for deployed applications.\nGit push to project repo triggers Coolify build\nCoolify builds Docker image, deploys container\nSSL via Coolify’s built-in Let’s Encrypt integration (or Tailscale for internal-only apps)\nPreview deployments for review, production deployments on approval\n\n4. Memory Architecture\nThree memory systems serve different purposes, ensuring agents always have the right context without token bloat.\n4.1 Three-Layer Memory Model\nLayer\nTool\nScope\nStorage\nUsed By\nWorking Memory\nOpenClaw built-in\nCurrent session\n~/.openclaw/sessions/*.jsonl\nOpenClaw\nProject Memory\nBeads\nPer-project decisions & context\n/srv/projects/{project}/.beads/\nAuto-Claude, Spec-kit\nPersonal Memory\nmem0\nCross-project preferences & facts\nQdrant vector DB + service\nOpenClaw, Dashboard, all agents\nKnowledge Base\nObsidian Vault\nAll structured knowledge\n/srv/vault/\nAll agents, human (Obsidian app)\n\n4.2 Beads (Per-Project Memory)\nBeads is an open-source project memory tool that maintains structured context across coding sessions. Each project gets a .beads/ directory tracking decisions, blockers, progress, and technical context.\nExample Beads entries: “Decided to use Supabase for auth”, “Blocked on WebSocket reconnection logic”, “Next: implement user profile page”, “Architecture: React + Tailwind + Vite”\nLocation: /srv/projects/{project}/.beads/\nWritten by: Auto-Claude during build phases\nRead by: Auto-Claude on session resume, Spec-kit for context\n4.3 mem0 (Personal OS Memory)\nmem0 is a persistent memory layer with hybrid vector + optional graph storage. It captures cross-project preferences, personal facts, and interaction patterns.\nExample mem0 entries: “User prefers React over Vue”, “User’s timezone is CET”, “User approved Sonnet 4.5 for mid-complexity tasks”, “User dislikes verbose logging”\nRuns as: Docker container on VPS (localhost:8050) + Qdrant (localhost:6333)\nMCP integration: Exposed as MCP tool for OpenClaw and other agents\nVault linking: mem0 entries include vault_path metadata pointing to source notes\n4.4 Obsidian Vault (Knowledge Base)\nThe vault is the canonical source of truth—human-readable, tool-agnostic, durable. All agents write to it; mem0 and Beads index from it.\n5. Vault Structure\nPath\nPurpose\nWrite Access\n/srv/vault/00_inbox/\nRaw captures from Telegram/Dashboard\nOpenClaw\n/srv/vault/01_daily/\nDaily notes, plans, recaps\nOpenClaw\n/srv/vault/02_projects/\nProject specs, designs, decisions\nSpec-kit, Stitch output, Auto-Claude\n/srv/vault/03_ideas/\nIdeas + Council verdicts\nOpenClaw, Council agents\n/srv/vault/04_notes/\nReference notes, research\nOpenClaw\n/srv/vault/05_events/\nCalendar events, meetings\nOpenClaw\n/srv/vault/06_system/\nSystem config, logs, security audits\nPreflight scripts, agents\n/srv/vault/_assets/\nImages, audio, attachments\nOpenClaw\n/srv/vault/_templates/\nNote templates for each type\nManual\n\n5.1 Project Folder Structure\nEach project in /srv/vault/02_projects/{project}/ contains:\n.specify/ — Spec-kit output (constitution, specs, plans, tasks)\ndesigns/ — Stitch-generated UI code and screenshots\ndecisions/ — Architecture decisions and tradeoffs\nCOUNCIL_VERDICT.md — AI Council evaluation result\nREADME.md — Project overview and status\nThe actual code lives at /srv/projects/{project}/ (separate from vault) with a GitHub remote for backup. The vault stores knowledge about the project; the repo stores the code.\n\n6. Security Model\nThe security model is informed by Nate’s comprehensive analysis of OpenClaw/Moltbot vulnerabilities and the broader community’s documented failure modes.\n6.1 What We Are NOT Doing (v1)\nNO ClawHub skills — zero moderation, documented supply-chain attacks\nNO public internet exposure — everything behind Tailscale\nNO email/calendar integration in Phase 1 — prompt injection risk too high\nNO unrestricted shell execution — Docker sandbox + safeBins allowlist\nNO auto-execution on untrusted input — all destructive actions require approval\nNO plaintext API keys — environment variables or secrets manager only\n6.2 Security Checklist (Pre-Deploy)\n#\nCheck\nTool\nBlocks Deploy?\n1\nGateway binds to 127.0.0.1 (not 0.0.0.0)\nPincer\nYes\n2\nNo ClawHub skills installed\nManual\nYes\n3\nsafeBins allowlist configured\nPincer\nYes\n4\nTelegram dmPolicy: pairing\nConfig review\nYes\n5\nAuto-Claude security profiles enabled\nConfig review\nYes\n6\nDocker sandbox for exec tools\nConfig review\nYes\n7\nVault permissions: 0640 files, 0750 dirs\nPreflight script\nYes\n8\nAPI keys in env vars (not config files)\nPincer + grep\nYes\n9\nNo services exposed on 0.0.0.0\nss -tlnp check\nYes\n10\nCoolify behind Tailscale (not public)\nConfig review\nYes\n11\nmem0 service on localhost only\nDocker config\nYes\n12\nPincer scan passes\npincer.sh scan\nYes\n13\nOpenClaw security audit passes\nopenclaw security audit --deep\nYes\n\n6.3 Industry Vulnerabilities → Our Mitigations\nDocumented Vulnerability\nOur Mitigation\nExposed instances (0.0.0.0 binding + port forwarding)\nGateway on 127.0.0.1, Tailscale Serve, UFW deny all, Pincer enforces\nLocalhost trust bypass via reverse proxies\nTailscale identity headers, trustedProxies configuration\nClawHub supply chain (zero moderation, fake skills)\nComplete ClawHub ban—no downloaded skills, custom only\nPrompt injection via email/calendar\nNo email/calendar integration in Phase 1\nPlaintext credential storage\nEnvironment variables, never in config files\nUnrestricted shell access\nDocker sandbox, safeBins allowlist, Auto-Claude security profiles\n\n\n7. Model Strategy & Cost Control\nToken costs scale fast in agentic workflows. The strategy is three-tier routing: cheap models for high-frequency tasks, mid-tier for synthesis, premium for deep work.\n7.1 Model Routing\nTier\nUse Case\nRecommended Model\nEst. Cost/Day\nA — Capture/Triage\nClassify, tag, file, quick replies\nClaude Haiku 4.5 or GPT-5 mini\n$0.13–$0.35\nB — Synthesis\nDaily plans, project summaries, Council agents\nClaude Sonnet 4.5 or GPT-5\n$0.63–$1.05\nC — Deep Work\nAuto-Claude builds, complex debugging, architecture\nClaude Opus 4.5\n$1.75 (use sparingly)\n\n7.2 Cost Optimization Levers\nPrompt caching: Anthropic supports cache-hit pricing for repetitive system prompts\nContext compaction: OpenClaw’s built-in compaction reduces token usage over long sessions\nmem0 retrieval: Fetch only relevant memories instead of stuffing full history\nBeads context: Structured project context is more token-efficient than raw chat history\nCouncil agents use Sonnet, not Opus: Evaluation doesn’t need maximum intelligence\n8. Dashboard Screens\nThe Dashboard is a React + Tailwind application built using Auto-Claude, following the Focus Flow design reference. It runs as a Docker container managed by Coolify, accessible via Tailscale Serve.\n8.1 Screen Inventory\n#\nScreen\nPurpose\nKey Features\n1\nDashboard (Home)\nDaily overview + quick actions\nToday’s brief, inbox summary, active projects, wellbeing, approvals queue\n2\nQuick Capture\nFast input with auto-routing\nLarge text area, voice input, auto-classification badge, confidence indicator\n3\nVoice Cockpit\nHands-free interaction\nWaveform visualizer, transcript, suggested actions panel\n4\nInbox Processing\nTriage unprocessed items\nSortable list, batch actions, inline processing\n5\nItem Processing Panel\nDetailed item editing\nClassification tabs, AI insight, project picker, tags\n6\nCalendar & Time Blocking\nSchedule visualization\nWeekly view, drag-to-create, focus blocks, deep work indicator\n7\nProjects Management\nAll projects overview\nProgress bars, vault paths, status badges\n8\nProject Workspace\nSingle project detail\nTasks, notes, activity, related ideas, deadlines\n9\nIdeas Explorer\nIdea pipeline management\nCard grid, status filters, Council verdicts, promote-to-project\n10\nWellbeing Tracker\nHealth & energy monitoring\nMood/energy sliders, sleep/exercise inputs, coach nudges, sparklines\n\n8.2 Design System\nToken\nValue\nUsage\nPrimary\n#137FEC\nButtons, active states, links\nBackground Dark\n#101922\nPage backgrounds\nSurface Dark\n#1C2630\nCards, panels\nBorder Dark\n#2A3B4D\nBorders, dividers\nText Muted\n#92ADC9\nSecondary text\nAccent Teal\n#2DD4BF\nSuccess, wellbeing\nFont\nInter\nAll text\nBorder Radius\n0.75rem (xl)\nCards, buttons\nIcons\nMaterial Symbols Outlined\nNavigation, actions\n\n\n9. Docker Compose Structure\nServices are organized into a single docker-compose.yml with explicit network isolation. All services bind to 127.0.0.1.\n9.1 Core Services\nService\nImage / Build\nVolumes\nDepends On\nopenclaw\nopenclaw/openclaw:latest\n~/.openclaw:/data, /srv/vault:/vault\n—\nmem0-service\nmem0ai/mem0:latest\n—\nqdrant\nqdrant\nqdrant/qdrant:latest\nqdrant-data:/qdrant/storage\n—\ncoolify\ncoollabsio/coolify:latest\n/var/run/docker.sock, coolify-data:/data\n—\ndashboard\nBuilt by Coolify from git\n—\nManaged by Coolify\n\n9.2 Host Services (Not in Docker)\nAuto-Claude + Claude Code CLI: Runs on host (needs direct filesystem + git access)\nSyncthing: Runs on host (needs direct filesystem access for vault sync)\nTailscale: Runs on host (manages network interface)\nSpec-kit: Runs on host via uvx (Python tool, invoked on-demand)\nBeads: Runs on host (file-based, per-project .beads/ directories)\n\n10. Implementation Phases\nPhase 0 — Foundation (Week 1)\nGoal: Secure infrastructure, vault structure, Tailscale-only access.\nVerify Tailscale is running, UFW blocks all non-Tailscale inbound\nCreate vault directory structure at /srv/vault/\nFix Syncthing sync between VPS and Mac\nInstall Pincer, run initial audit\nInstall Docker, Docker Compose\nDeploy Coolify on VPS\nPhase 1 — Capture & Classify (Week 2–3)\nGoal: Telegram → OpenClaw → vault working reliably.\nRestart OpenClaw, configure Telegram bot with dmPolicy: pairing\nConfigure OpenClaw to write to /srv/vault/00_inbox/\nSet up classification rules (Task/Idea/Note/Event routing)\nConfigure model routing: Haiku 4.5 for capture/classify\nRun security checklist, fix all findings\nTest: send 20 messages via Telegram, verify correct vault routing\nPhase 2 — Dashboard MVP + Memory (Week 4–6)\nGoal: Dashboard live behind Tailscale, mem0 running, daily workflows working.\nInstall Claude Code CLI on VPS, authenticate\nSet up Auto-Claude on VPS\nUse Auto-Claude to build Dashboard MVP (Home + Capture + Inbox screens)\nDeploy Dashboard via Coolify\nDeploy mem0 + Qdrant in Docker\nConnect OpenClaw to mem0 via MCP\nSet up daily note writer + morning brief\nInstall whisper.cpp + Piper on Mac for voice loop (optional)\nPhase 3 — AI Council + Spec Pipeline (Week 7–9)\nGoal: Ideas pipeline complete: capture → validate → spec.\nBuild Council sub-agents in OpenClaw (Feasibility, Alignment, Impact, Synthesizer)\nBuild Ideas Explorer and Item Processing screens with Auto-Claude\nInstall Spec-kit (uvx --from git+https://github.com/github/spec-kit.git)\nTest end-to-end: idea → council → approval → spec generation\nSet up Beads for first project\nConsider Flowise installation for complex workflow orchestration\nPhase 4 — Autonomous Build Pipeline (Week 10–12)\nGoal: Full idea-to-deployment pipeline working.\nIntegrate Gemini CLI for Stitch UI generation (or establish manual workflow)\nConfigure Claude-code with Beads context loading\nBuild remaining Dashboard screens (Calendar, Projects, Wellbeing, Voice Cockpit)\nSet up Coolify auto-deploy from git push\nTest end-to-end: idea → council → spec → design → build → deploy\nPhase 5 — Polish & Expand (Week 13+)\nGoal: Refinement, additional integrations, Flowise upgrade.\nMigrate Council to Flowise for visual workflow orchestration\nAdd wellbeing tracking integrations\nExpand voice interaction (STT/TTS on Mac + Telegram voice notes)\nPerformance optimization: prompt caching, context compaction tuning\nConsider additional messaging channels (Discord, Slack)\n\n11. Risks & Mitigations\nRisk\nSeverity\nMitigation\nToken costs spiral in agentic loops\nHigh\nThree-tier model routing, prompt caching, compaction, budget alerts\nAuto-Claude modifies system files\nCritical\nDocker sandbox, safeBins, git worktree isolation, security profiles\nmem0 memory poisoning\nMedium\nGate memory writes through curated functions, not raw agent output\nVault sync conflicts (Syncthing)\nMedium\nConflict resolution rules, one-writer-per-folder principle\nOpenClaw instability after updates\nMedium\nPin versions, test in staging before applying updates\nGoogle Stitch API changes or shutdown\nLow\nFallback to manual design + existing mockups as reference\nSingle VPS = single point of failure\nMedium\nHetzner snapshots, GitHub for code, vault backup via Syncthing\nCouncil sub-agents give bad advice\nLow\nUser always has final approval; Council is advisory only\n\n12. Tool Reference\nTool\nVersion/Source\nLicense\nPurpose in Stack\nOpenClaw\ngithub.com/openclaw/openclaw\nOpen Source\nCore AI assistant, Telegram bot, classification, orchestration\nGitHub Spec-kit\ngithub.com/github/spec-kit\nMIT\nSpec-Driven Development: PRDs, plans, tasks from natural language\nAuto-Claude\ngithub.com/AndyMik90/Auto-Claude\nOpen Source\nAutonomous multi-agent coding: Spec→Plan→Code→QA→Fix\nGoogle Stitch\nstitch.withgoogle.com\nFree (Google Labs)\nAI UI design: text/image → HTML/CSS/React\nCoolify\ncoolify.io\nOpen Source\nSelf-hosted PaaS: Docker deploys, SSL, domains\nBeads\ngithub.com/steveyegge/beads\nMIT\nPer-project memory for coding agents\nmem0\ngithub.com/mem0ai/mem0\nOpen Source\nPersistent personal memory layer (vector + graph)\nTailscale\ntailscale.com\nFreemium\nZero-trust networking, identity headers\nSyncthing\nsyncthing.net\nMPL-2.0\nVault sync between VPS and Mac/iPhone\nPincer\ngithub.com/masbindev/pincer\nOpen Source\nSecurity audit for OpenClaw gateway config\nFlowise\ngithub.com/FlowiseAI/Flowise\nApache 2.0\nFuture: Visual workflow builder for complex Council logic\n\n\n13. Appendix\n13.1 Key File Paths\nPath\nWhat\n/srv/vault/\nObsidian vault root (synced to Mac/iPhone)\n/srv/projects/\nCode repositories root\n/srv/projects/{project}/.beads/\nBeads project memory\n/srv/projects/{project}/.specify/\nSpec-kit output\n~/.openclaw/\nOpenClaw config and session logs\n/opt/pincer/\nPincer security audit tool\n/usr/local/bin/openclaw-preflight\nPre-deploy security gate script\n\n13.2 GitHub Repository\nInfrastructure as code, configuration templates, and documentation live at:\nhttps://github.com/vimo33/focus-flow-os\n13.3 Design Reference\nThe 10 dashboard mockups in design_reference.md define the visual language for all Dashboard screens. Auto-Claude and Google Stitch should reference these when generating UI components.\n\n— End of Document —",
  "source": "text",
  "created_at": "2026-02-12T13:25:11.537Z"
}