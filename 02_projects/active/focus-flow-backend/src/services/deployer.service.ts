import { exec } from 'child_process';
import * as fs from 'fs/promises';
import * as path from 'path';
import { GeneratedCode, DeploymentResult } from '../models/types';

/**
 * DeployerService - Deploys generated code to filesystem and optionally to git
 *
 * Writes frontend and backend files to their respective directories and
 * optionally creates git commits.
 */
export class DeployerService {
  /**
   * Deploy generated code
   */
  async deploy(code: GeneratedCode): Promise<DeploymentResult> {
    const deployed: DeploymentResult = {
      frontend_files: [],
      backend_files: [],
      git_commit: null,
    };

    // Write frontend files
    for (const frontend of code.frontend) {
      await this.ensureDirectoryExists(frontend.file_path);
      await fs.writeFile(frontend.file_path, frontend.code, 'utf-8');
      deployed.frontend_files.push(frontend.file_path);

      console.log(`✓ Deployed frontend: ${frontend.file_path}`);
    }

    // Write backend files
    for (const backend of code.backend) {
      await this.ensureDirectoryExists(backend.file_path);
      await fs.writeFile(backend.file_path, backend.code, 'utf-8');
      deployed.backend_files.push(backend.file_path);

      console.log(`✓ Deployed backend: ${backend.file_path}`);
    }

    // Write test files
    for (const test of code.tests) {
      await this.ensureDirectoryExists(test.file_path);
      await fs.writeFile(test.file_path, test.code, 'utf-8');

      console.log(`✓ Deployed test: ${test.file_path}`);
    }

    // Commit to git (optional)
    if (process.env.AUTO_COMMIT === 'true') {
      deployed.git_commit = await this.gitCommit(code);
    }

    return deployed;
  }

  /**
   * Ensure parent directory exists for a file path
   */
  private async ensureDirectoryExists(filePath: string): Promise<void> {
    const dir = path.dirname(filePath);
    await fs.mkdir(dir, { recursive: true });
  }

  /**
   * Create git commit for generated code
   */
  private async gitCommit(code: GeneratedCode): Promise<string> {
    const componentNames = code.frontend.map((f) => f.component_name).join(', ');
    const routeNames = code.backend.map((b) => b.route_file).join(', ');

    const message = `feat: autonomous generation of ${code.frontend.length} components, ${code.backend.length} routes

Components: ${componentNames}
Routes: ${routeNames}

Generated by Focus Flow Orchestrator

Co-Authored-By: Focus Flow Orchestrator <noreply@focusflow.dev>`;

    return new Promise((resolve, reject) => {
      const cmd = `git add . && git commit -m "${message.replace(/"/g, '\\"')}"`;

      exec(cmd, { cwd: '/srv/focus-flow' }, (error, stdout, stderr) => {
        if (error) {
          console.error('Git commit failed:', error.message);
          reject(new Error(`Git commit failed: ${error.message}`));
          return;
        }

        console.log('✓ Git commit created:', stdout);
        resolve(message);
      });
    });
  }

  /**
   * Rollback deployment (delete deployed files)
   */
  async rollback(deployment: DeploymentResult): Promise<void> {
    console.log('Rolling back deployment...');

    // Delete frontend files
    for (const file of deployment.frontend_files) {
      try {
        await fs.unlink(file);
        console.log(`✓ Deleted: ${file}`);
      } catch (error: any) {
        console.warn(`Failed to delete ${file}: ${error.message}`);
      }
    }

    // Delete backend files
    for (const file of deployment.backend_files) {
      try {
        await fs.unlink(file);
        console.log(`✓ Deleted: ${file}`);
      } catch (error: any) {
        console.warn(`Failed to delete ${file}: ${error.message}`);
      }
    }

    // If git commit was made, revert it
    if (deployment.git_commit && process.env.AUTO_COMMIT === 'true') {
      await this.gitRevert();
    }
  }

  /**
   * Revert last git commit
   */
  private async gitRevert(): Promise<void> {
    return new Promise((resolve, reject) => {
      exec('git reset --soft HEAD~1', { cwd: '/srv/focus-flow' }, (error) => {
        if (error) {
          console.error('Git revert failed:', error.message);
          reject(new Error(`Git revert failed: ${error.message}`));
          return;
        }

        console.log('✓ Git commit reverted');
        resolve();
      });
    });
  }
}
